// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// Check for compatibility between `uniffi` and `uniffi_bindgen` versions.
// Note that we have an error message on the same line as the assertion.
// This is important, because if the assertion fails, the compiler only
// seems to show that single line as context for the user.
uniffi::assert_compatible_version!("0.14.0"); // Please check that you depend on version 0.14.0 of the `uniffi` crate.

// Everybody gets basic buffer support, since it's needed for passing complex types over the FFI.

/// This helper allocates a new byte buffer owned by the Rust code, and returns it
/// to the foreign-language code as a `RustBuffer` struct. Callers must eventually
/// free the resulting buffer, either by explicitly calling the destructor defined below,
/// or by passing ownership of the buffer back into Rust code.
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_didcomm_rs_b50c_rustbuffer_alloc(
    size: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        uniffi::RustBuffer::new_with_size(size.max(0) as usize)
    })
}

/// This helper copies bytes owned by the foreign-language code into a new byte buffer owned
/// by the Rust code, and returns it as a `RustBuffer` struct. Callers must eventually
/// free the resulting buffer, either by explicitly calling the destructor defined below,
/// or by passing ownership of the buffer back into Rust code.
///
/// # Safety
/// This function will dereference a provided pointer in order to copy bytes from it, so
/// make sure the `ForeignBytes` struct contains a valid pointer and length.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_didcomm_rs_b50c_rustbuffer_from_bytes(
    bytes: uniffi::ForeignBytes,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        let bytes = bytes.as_slice();
        uniffi::RustBuffer::from_vec(bytes.to_vec())
    })
}

/// Free a byte buffer that had previously been passed to the foreign language code.
///
/// # Safety
/// The argument *must* be a uniquely-owned `RustBuffer` previously obtained from a call
/// into the Rust code that returned a buffer, or you'll risk freeing unowned memory or
/// corrupting the allocator state.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_didcomm_rs_b50c_rustbuffer_free(
    buf: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::call_with_output(call_status, || uniffi::RustBuffer::destroy(buf))
}

/// Reserve additional capacity in a byte buffer that had previously been passed to the
/// foreign language code.
///
/// The first argument *must* be a uniquely-owned `RustBuffer` previously
/// obtained from a call into the Rust code that returned a buffer. Its underlying data pointer
/// will be reallocated if necessary and returned in a new `RustBuffer` struct.
///
/// The second argument must be the minimum number of *additional* bytes to reserve
/// capacity for in the buffer; it is likely to reserve additional capacity in practice
/// due to amortized growth strategy of Rust vectors.
///
/// # Safety
/// The first argument *must* be a uniquely-owned `RustBuffer` previously obtained from a call
/// into the Rust code that returned a buffer, or you'll risk freeing unowned memory or
/// corrupting the allocator state.
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_didcomm_rs_b50c_rustbuffer_reserve(
    buf: uniffi::RustBuffer,
    additional: i32,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::call_with_output(call_status, || {
        use std::convert::TryInto;
        let additional: usize = additional
            .try_into()
            .expect("additional buffer length negative or overflowed");
        let mut v = buf.destroy_into_vec();
        v.reserve(additional);
        uniffi::RustBuffer::from_vec(v)
    })
}

// Error definitions, corresponding to `error` in the UDL.

// Enum defitions, corresponding to `enum` in UDL.

// Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.

// Top level functions, corresponding to UDL `namespace` functions.// Object definitions, corresponding to UDL `interface` definitions.

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_didcomm_rs_b50c_Message_object_free(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::call_with_output(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { std::sync::Arc::from_raw(ptr as *const Message) })
    })
}
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_new(
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void /* *const Message */ {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_new");

    // If the constructor does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let _new = Message::new();
        let _arc = std::sync::Arc::new(_new);
        <std::sync::Arc<Message> as uniffi::FfiConverter>::lower(_arc)
    })
}
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_new_receive(
    incomming: uniffi::RustBuffer,
    sk: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> *const std::os::raw::c_void /* *const Message */ {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_new_receive");

    // If the constructor does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let _new = Message::new_receive(
            &<String as uniffi::FfiConverter>::try_lift(incomming).unwrap(),
            &<std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(sk).unwrap(),
        );
        let _arc = std::sync::Arc::new(_new);
        <std::sync::Arc<Message> as uniffi::FfiConverter>::lower(_arc)
    })
}
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_get_to(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_get_to");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = Message::get_to(
            &<std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
        );
        <std::vec::Vec<String> as uniffi::FfiConverter>::lower(retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_set_to(
    ptr: *const std::os::raw::c_void,
    str: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_set_to");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        Message::set_to(
            <std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
            <std::vec::Vec<String> as uniffi::FfiConverter>::try_lift(str).unwrap(),
        )
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_get_from(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_get_from");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = Message::get_from(
            &<std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
        );
        <String as uniffi::FfiConverter>::lower(retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_set_from(
    ptr: *const std::os::raw::c_void,
    from: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_set_from");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        Message::set_from(
            <std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
            <String as uniffi::FfiConverter>::try_lift(from).unwrap(),
        )
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_get_body2(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_get_body2");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = Message::get_body2(
            &<std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
        );
        <std::vec::Vec<u8> as uniffi::FfiConverter>::lower(retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_set_body2(
    ptr: *const std::os::raw::c_void,
    body: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_set_body2");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        Message::set_body2(
            <std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
            &<std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(body).unwrap(),
        )
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_as_raw_json2(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_as_raw_json2");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = Message::as_raw_json2(
            &<std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
        );
        <String as uniffi::FfiConverter>::lower(retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_set_crypto_algorithm_xc20_p(
    ptr: *const std::os::raw::c_void,
    call_status: &mut uniffi::RustCallStatus,
) {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_set_crypto_algorithm_xc20_p");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        Message::set_crypto_algorithm_xc20_p(
            <std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
        )
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_unwrap_base58_key(
    ptr: *const std::os::raw::c_void,
    key: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_unwrap_base58_key");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = Message::unwrap_base58_key(
            &<std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
            <String as uniffi::FfiConverter>::try_lift(key).unwrap(),
        );
        <std::vec::Vec<u8> as uniffi::FfiConverter>::lower(retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_seal2(
    ptr: *const std::os::raw::c_void,
    sk: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_seal2");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = Message::seal2(
            &<std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
            &<std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(sk).unwrap(),
        );
        <String as uniffi::FfiConverter>::lower(retval)
    })
}

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn didcomm_rs_b50c_Message_set_routed_by(
    ptr: *const std::os::raw::c_void,
    ekey: uniffi::RustBuffer,
    mediator_did_string: uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus,
) -> uniffi::RustBuffer {
    uniffi::deps::log::debug!("didcomm_rs_b50c_Message_set_routed_by");
    // If the method does not have the same signature as declared in the UDL, then
    // this attempt to call it will fail with a (somewhat) helpful compiler error.

    uniffi::call_with_output(call_status, || {
        let retval = Message::set_routed_by(
            &<std::sync::Arc<Message> as uniffi::FfiConverter>::try_lift(ptr).unwrap(),
            &<std::vec::Vec<u8> as uniffi::FfiConverter>::try_lift(ekey).unwrap(),
            &<String as uniffi::FfiConverter>::try_lift(mediator_did_string).unwrap(),
        );
        <String as uniffi::FfiConverter>::lower(retval)
    })
}

// Callback Interface definitions, corresponding to UDL `callback interface` definitions.

// External and Wrapped types
// Support for external types.

// Types with an external `FfiConverter`...

// More complicated locally `Wrapped` types - we generate FfiConverter.
